---
description: Core MaCo API workspace context and file structure - always applied
alwaysApply: true
tags: [context, workspace, maco-api, global]
priority: 1
version: 1.0.0
---

# MaCo API Workspace - Global Context

## Workspace Role & Goal

- **Role**: Lieferant (LF) - electricity supplier
- **Goal**: Enable backend to use MaCo API to communicate MaKo (Market Communication) messages into the market and receive results from market
- **Approach**: Support both business-concept-driven discovery and technical message-driven implementation
- **Future Vision**: Agent system that uses database entries to pre-create messages, validates against Conuti, and provides feedback on missing fields/functionality

## Core File Structure

**Always Available Files**:
- `docs/entry-points/PROCESS_GRAPH.json` - Process dependencies & sequences (machine-readable, fast lookup)
- `docs/entry-points/BUSINESS_PROCESS_MAP.md` - Business goal discovery (Entry Point 1)
- `docs/entry-points/AI_AGENT_SETUP.md` - Technical implementation (Entry Point 2)
- `docs/llm.txt` - Documentation index (237 entries) - Find which docs you need
- `docs-offline/` - 232 offline documentation files (Prozessübersicht, process descriptions, EBD diagrams)
- `maco-edi-testfiles/` - 2,549+ EDI test files (real-world message examples)
  - **⚠️ CRITICAL**: Always use `v202510` version directory, NOT `v202404` or other versions
  - **v202510 Structure** (reflects actual workflow):
    - **Inbound examples**: `maco-edi-testfiles/inbound/v202510/` - EDIFACT format (`.edi` files only)
      - Messages FROM NB/MSB (webhooks, responses) - received as EDIFACT
    - **Outbound examples**: `maco-edi-testfiles/outbound/v202510/` - BO4E JSON format (`.json` files only)
      - Messages TO Conuti API (triggers, requests) - sent as BO4E JSON
  - **⚠️ NEVER use v202404** - it's outdated and has different structure (both formats for both directions)

**API Schema Files** (`maco-api-documentation/_build/`):
- `bo4e-openapi.min.json` - BO4E data structures and types
- `macoapp-schreiben.min.json` - Write operations (storing process data)
- `macoapp-lesen.min.json` - Read operations (reading BO4E objects)
- `macoapp-trigger.min.json` - Trigger events (outbound to Conuti)
- `maloident-macoapp.min.json` - MaloIdent requests (outbound)
- `maloident-lieferant.min.json` - MaloIdent responses (inbound webhooks)

## Key Concepts

- **Process IDs**: BDEW Prüfidentifikatoren (5-digit numbers, e.g., "55077")
- **API Direction**:
  - **Outbound**: Backend calls Conuti API (trigger, send data)
  - **Inbound**: Conuti calls backend webhooks (receive responses, receive data)
- **Processes are asynchronous**: Responses come from NB (network operator) and MSB (meter operator)
- **All `.min.json` files are formatted** (not minified) for readability

## Process Lookup (PROCESS_GRAPH.json)

**IMPORTANT**: `PROCESS_GRAPH.json` is a **minimal index** that points to source files. It does NOT contain interpreted/processed data.

**Philosophy**: "Point, don't interpret" - Use the index to discover files, then read source documentation for details.

**Use for discovery**:
- By pruefi: `indexes.by_bdew_id["55077"]` → list of files mentioning this Prüfi
- By trigger: `indexes.by_trigger["START_LIEFERBEGINN"]` → list of files with this trigger
- By process name: `indexes.by_process_name["lieferbeginn"]` → list of files for this process

**Then read source files**:
- Read the actual markdown files for full context
- Parse Mermaid diagrams directly from source
- Extract roles, prerequisites, relationships from source docs
- Cross-reference with API schemas and business rules

## Workflow Pattern

**CRITICAL**: Always read documentation files before answering. See anti-hallucination-mandatory-always.mdc for verification requirements.

1. **Identify entry point** (business goal vs. specific message)
2. **READ documentation FIRST** - Never guess or assume
3. **Use appropriate guide** (`docs/entry-points/BUSINESS_PROCESS_MAP.md` or `docs/entry-points/AI_AGENT_SETUP.md`)
4. **Use PROCESS_GRAPH.json for discovery** - Find relevant files via indexes, then READ those source files
5. **Read source documentation** - Parse Mermaid diagrams, extract roles/prerequisites/relationships from actual docs
6. **Reference documentation** via `docs/llm.txt` → docs-offline/
7. **Check examples** in maco-edi-testfiles/ (ALWAYS use v202510 version directory)
   - **Inbound**: `maco-edi-testfiles/inbound/v202510/` - EDIFACT format (`.edi` files)
     - Example: `maco-edi-testfiles/inbound/v202510/utilmd/55002/1.edi`
     - These show what you RECEIVE from NB/MSB (webhooks, responses)
   - **Outbound**: `maco-edi-testfiles/outbound/v202510/` - BO4E JSON format (`.json` files)
     - Example: `maco-edi-testfiles/outbound/v202510/utilmd/55077/1.json`
     - These show what you SEND to Conuti API (triggers, requests)
   - ⚠️ **NEVER use v202404** - it's outdated and has different structure
8. **Verify against schemas** (PI_[ID].yml) and business rules (yaml_output/[ID].yaml)
9. **Cite sources** in your response (always cite the source file, not the index)
10. **Build implementation** using verified schemas and business rules from source docs
